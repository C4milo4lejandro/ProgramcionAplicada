# -*- coding: utf-8 -*-
"""Clases_atributos_y_métodos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qhTk5y98txTlFF8DZfBTwBFXDGUanZic
"""

class Book:
    def __init__(self, title, quantity, author, price):
      #__init__ se utiliza como constructor en Python
      #self permite acceder al contenido de la clase

        self.title = title
        self.quantity = quantity
        self.author = author
        self.price = price
        #Guarda el valor en el atributo del objeto

book1 = Book('Book 1', 12, 'Author 1', 120)
book2 = Book('Book 2', 18, 'Author 2', 220)
book3 = Book('Book 3', 28, 'Author 3', 320)

print(book1)
print(book2)
print(book3)
#Solo nos da la información del guardado de la información

class Book:
    def __init__(self, title, quantity, author, price):
        self.title = title
        self.quantity = quantity
        self.author = author
        self.price = price

    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.price}"
        #__repr__ es el método utilizado para que la información se devuelva clara y tal cual ingresada


book1 = Book('Sherlock Holmes', 12, 'Arthur Conan Doyle', 120)
book2 = Book('La Melancolía de los Feos', 18, 'Mario Mendoza', 220)
book3 = Book('Brevísima Historia del Tiempo', 28, 'Stephen Hawking', 320)

print(book1)
print(book2)
print(book3)

class Book:
    def __init__(self, title, quantity, author, price):
        self.title = title
        self.quantity = quantity
        self.author = author
        self.price = price
        self.__discount = 0.10
        #Se agrega un nuevo atributo, y al llevar dos guiones bajos se hace privada

    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.price}"


book1 = Book('Book 1', 12, 'Author 1', 120)

print(book1.title)
print(book1.quantity)
print(book1.author)
print(book1.price)
print(book1.__discount)

#Marca error ya que como se declaró privado, esta no es la manera de acceder a él

class Book:
    def __init__(self, title, quantity, author, price):
        self.title = title
        self.quantity = quantity
        self.author = author
        self.__price = price
        #Se privatiza el atributo price
        self.__discount = None
        #Se deja declarado el atributo privado

    def set_discount(self, discount):
        self.__discount = discount
        #Método setter para acceder al atributo privado

    def get_price(self):
        if self.__discount:
            return self.__price * (1-self.__discount)
        return self.__price
        #Método getter para acceder al atributo privado

    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"

single_book = Book('Two States', 1, 'Chetan Bhagat', 200)
#Se declara un único libro con sus atributos

bulk_books = Book('Two States', 25, 'Chetan Bhagat', 200)
bulk_books.set_discount(0.20)
#Otra declaración de libro, pero sin empacar para aplicar el descuento

print(single_book.get_price())
#Precio del libro único

print(bulk_books.get_price())
#Precio del libro sin empacar

print(single_book)
#Atributos del libro único

print(bulk_books)
#Atributos del libro sin empacar

class Book:
    def __init__(self, title, quantity, author, price):
        self.title = title
        self.quantity = quantity
        self.author = author
        self.__price = price
        self.__discount = None

    #Método para asignar descuento
    def set_discount(self, discount):
        self.__discount = discount

    #Método para asignar el precio menos el descuento cuando lo haya
    def get_price(self):
        if self.__discount:
            return self.__price * (1-self.__discount)
        return self.__price

    #Método para imprimir la información de cada libro de manera organizada
    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"


class Novel(Book):
    def __init__(self, title, quantity, author, price, pages):
        super().__init__(title, quantity, author, price)
        #super() es usado para la herencia de la clase book y no reescribir todos los métodos
        self.pages = pages


class Academic(Book):
    def __init__(self, title, quantity, author, price, branch):
        super().__init__(title, quantity, author, price)
        self.branch = branch

novel1 = Novel('Two States', 20, 'Chetan Bhagat', 200, 187)
novel1.set_discount(0.20)

academic1 = Academic('Python Foundations', 12, 'PSF', 655, 'IT')

print(novel1)
print(academic1)

class Academic(Book):
    def __init__(self, title, quantity, author, price, branch):
        super().__init__(title, quantity, author, price)
        self.branch = branch

    def __repr__(self):
        return f"Book: {self.title}, Branch: {self.branch}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"

novel1 = Novel('Two States', 20, 'Chetan Bhagat', 200, 187)
novel1.set_discount(0.20)

academic1 = Academic('Python Foundations', 12, 'PSF', 655, 'IT')

print(novel1)
print(academic1)

from abc import ABC, abstractmethod
#Se usa para clases abstractas, en las que se declara una "plantilla" para otras clases hijas

class Book(ABC):
    def __init__(self, title, quantity, author, price):
        self.title = title
        self.quantity = quantity
        self.author = author
        self.__price = price
        self.__discount = None

    def set_discount(self, discount):
        self.__discount = discount

    def get_price(self):
        if self.__discount:
            return self.__price * (1-self.__discount)
        return self.__price

    @abstractmethod
    #Define que todas las clases hijas de aqui, obligatoriamente toma este método
    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"


class Novel(Book):
    def __init__(self, title, quantity, author, price, pages):
        super().__init__(title, quantity, author, price)
        self.pages = pages
    def __repr__(self):
        return f"Book: {self.title}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"


class Academic(Book):
    def __init__(self, title, quantity, author, price, branch):
        super().__init__(title, quantity, author, price)
        self.branch = branch

    def __repr__(self):
        return f"Book: {self.title}, Branch: {self.branch}, Quantity: {self.quantity}, Author: {self.author}, Price: {self.get_price()}"


novel1 = Novel('Two States', 20, 'Chetan Bhagat', 200, 187)
novel1.set_discount(0.20)

academic1 = Academic('Python Foundations', 12, 'PSF', 655, 'IT')

print(novel1)
print(academic1)

class OverloadingDemo:
    #def add(self, x, y):
        #print(x+y)

    def add(self, x, y, z):
        print(x+y+z)

    #Dependiendo de la cantidad de atributos se declaran dos métodos para sumar según los que se ingresen 3 líneas más abajo
    #Se recomendaría cambiar el nombre de alguno de los métodos para evitar errores en el código

obj = OverloadingDemo()
obj.add(2, 3, 5)

class ParentClass:
    def call_me(self):
        print("I am parent class")

class ChildClass(ParentClass):
    def call_me(self):
        print("I am child class")
    #En esta clase el hecho de que herede es algo infructuosa, porque se reescribe el único método de ParentClass

pobj = ParentClass()
pobj.call_me()

cobj = ChildClass()
cobj.call_me()
#Depende de a qué clase, si a la padre o a la hija, se imprime el método diferente
